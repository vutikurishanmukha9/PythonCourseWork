import speech_recognition as sr
import pyttsx3
import random

class FriendlyAssistant:
    def __init__(self):
        try:
            self.engine = pyttsx3.init()
            print("ЁЯФД Initializing speech engine...")
        except Exception as e:
            print(f"тЪая╕П Warning: Speech engine initialization failed: {e}")
            self.engine = None
            
        self.current_language = 'en'  # Default language
        self.speech_working = True
        self.language_codes = {
            'english': 'en',
            'spanish': 'es',
            'french': 'fr',
            'german': 'de',
            'italian': 'it',
            'portuguese': 'pt',
            'russian': 'ru',
            'japanese': 'ja',
            'chinese': 'zh',
            'korean': 'ko',
            'arabic': 'ar',
            'hindi': 'hi',
            'bengali': 'bn',
            'tamil': 'ta',
            'telugu': 'te',
            'marathi': 'mr',
            'gujarati': 'gu',
            'punjabi': 'pa'
        }
        
        # Friendly responses in different languages
        self.responses = {
            'greetings': {
                'en': [
                    "Hi there! I'm your friendly virtual assistant. How can I brighten your day?",
                    "Hello! Great to see you! What can I help you with today?",
                    "Hey! I'm excited to help you today. What's on your mind?"
                ],
                'es': [
                    "┬бHola! Soy tu asistente virtual amigable. ┬┐C├│mo puedo alegrar tu d├нa?",
                    "┬бHola! ┬бGenial verte! ┬┐En qu├й puedo ayudarte hoy?"
                ],
                'fr': [
                    "Salut! Je suis votre assistant virtuel amical. Comment puis-je ├йgayer votre journ├йe?",
                    "Bonjour! Ravi de vous voir! Comment puis-je vous aider aujourd'hui?"
                ],
                'hi': [
                    "рдирдорд╕реНрддреЗ! рдореИрдВ рдЖрдкрдХрд╛ рдорд┐рддреНрд░рд╡рдд рдЖрднрд╛рд╕реА рд╕рд╣рд╛рдпрдХ рд╣реВрдВред рдЖрдЬ рдореИрдВ рдЖрдкрдХреА рдХреИрд╕реЗ рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдВ?",
                    "рд╣реИрд▓реЛ! рдЖрдкрд╕реЗ рдорд┐рд▓рдХрд░ рдЦреБрд╢реА рд╣реБрдИ! рдЖрдЬ рдореИрдВ рдЖрдкрдХреЗ рд▓рд┐рдП рдХреНрдпрд╛ рдХрд░ рд╕рдХрддрд╛ рд╣реВрдВ?"
                ]
            },
            'music': {
                'en': [
                    "Awesome choice! Let me get your music started right away! ЁЯО╡",
                    "Great! Time for some tunes! Music is now playing! ЁЯО╢",
                    "Perfect! Let's get this party started with some music! ЁЯОЙ"
                ],
                'es': [
                    "┬бExcelente elecci├│n! ┬бTe pongo m├║sica ahora mismo! ЁЯО╡",
                    "┬бGenial! ┬бEs hora de m├║sica! ┬бLa m├║sica est├б sonando! ЁЯО╢"
                ],
                'fr': [
                    "Excellent choix! Je lance votre musique tout de suite! ЁЯО╡",
                    "Parfait! C'est l'heure de la musique! ЁЯО╢"
                ],
                'hi': [
                    "рдмреЗрд╣рддрд░реАрди рдкрд╕рдВрдж! рдореИрдВ рдЕрднреА рдЖрдкрдХреЗ рд▓рд┐рдП рд╕рдВрдЧреАрдд рдЪрд▓рд╛ рд░рд╣рд╛ рд╣реВрдВ! ЁЯО╡",
                    "рд╢рд╛рдирджрд╛рд░! рд╕рдВрдЧреАрдд рдХрд╛ рд╕рдордп! ЁЯО╢"
                ]
            },
            'reminder': {
                'en': [
                    "Got it! I've set a friendly reminder for you to push code at 5pm. I'll make sure you don't forget! тП░",
                    "Perfect! Reminder set! I'll give you a gentle nudge at 5pm to push your code! ЁЯУЭ"
                ],
                'es': [
                    "┬бEntendido! He establecido un recordatorio para que subas el c├│digo a las 5pm. тП░",
                    "┬бPerfecto! ┬бRecordatorio establecido! ЁЯУЭ"
                ],
                'fr': [
                    "Compris! J'ai d├йfini un rappel pour pousser le code ├а 17h. тП░",
                    "Parfait! Rappel d├йfini! ЁЯУЭ"
                ],
                'hi': [
                    "рд╕рдордЭ рдЧрдпрд╛! рдореИрдВрдиреЗ рд╢рд╛рдо 5 рдмрдЬреЗ рдХреЛрдб рдкреБрд╢ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рд░рд┐рдорд╛рдЗрдВрдбрд░ рд╕реЗрдЯ рдХрд░ рджрд┐рдпрд╛ рд╣реИред тП░",
                    "рдкрд░рдлреЗрдХреНрдЯ! рд░рд┐рдорд╛рдЗрдВрдбрд░ рд╕реЗрдЯ рдХрд░ рджрд┐рдпрд╛! ЁЯУЭ"
                ]
            },
            'geopolitics': {
                'en': [
                    "That's a deep topic! Regarding geopolitics, transparency and civic engagement are indeed crucial for maintaining stability and addressing public concerns effectively.",
                    "Interesting question about geopolitics! Democratic participation and transparent governance are key to resolving conflicts peacefully."
                ],
                'es': [
                    "┬бEse es un tema profundo! En cuanto a geopol├нtica, la transparencia y la participaci├│n c├нvica son cruciales.",
                    "┬бPregunta interesante sobre geopol├нtica!"
                ],
                'fr': [
                    "C'est un sujet profond! Concernant la g├йopolitique, la transparence est cruciale.",
                    "Question int├йressante sur la g├йopolitique!"
                ],
                'hi': [
                    "рдпрд╣ рдПрдХ рдЧрд╣рд░рд╛ рд╡рд┐рд╖рдп рд╣реИ! рднреВ-рд░рд╛рдЬрдиреАрддрд┐ рдХреЗ рд╕рдВрдмрдВрдз рдореЗрдВ, рдкрд╛рд░рджрд░реНрд╢рд┐рддрд╛ рдФрд░ рдирд╛рдЧрд░рд┐рдХ рд╕рд╣рднрд╛рдЧрд┐рддрд╛ рдорд╣рддреНрд╡рдкреВрд░реНрдг рд╣реИред",
                    "рднреВ-рд░рд╛рдЬрдиреАрддрд┐ рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рджрд┐рд▓рдЪрд╕реНрдк рд╕рд╡рд╛рд▓!"
                ]
            },
            'goodbye': {
                'en': [
                    "It was wonderful chatting with you! Have an absolutely amazing day! Take care! ЁЯСЛ",
                    "Goodbye, my friend! Hope you have a fantastic day ahead! See you soon! ЁЯШК",
                    "Take care and have a beautiful day! It was great helping you! Bye! ЁЯМЯ"
                ],
                'es': [
                    "┬бFue maravilloso charlar contigo! ┬бQue tengas un d├нa incre├нble! ┬бCu├нdate! ЁЯСЛ",
                    "┬бAdi├│s, mi amigo! ┬бEspero que tengas un d├нa fant├бstico! ЁЯШК"
                ],
                'fr': [
                    "C'├йtait merveilleux de discuter avec vous! Passez une journ├йe fantastique! ЁЯСЛ",
                    "Au revoir, mon ami! J'esp├иre que vous passerez une excellente journ├йe! ЁЯШК"
                ],
                'hi': [
                    "рдЖрдкрд╕реЗ рдмрд╛рдд рдХрд░рдХреЗ рдмрд╣реБрдд рдЕрдЪреНрдЫрд╛ рд▓рдЧрд╛! рдЖрдкрдХрд╛ рджрд┐рди рд╢рд╛рдирджрд╛рд░ рд╣реЛ! рдЦреБрд╢ рд░рд╣рд┐рдП! ЁЯСЛ",
                    "рдЕрд▓рд╡рд┐рджрд╛, рдорд┐рддреНрд░! рдЖрдкрдХрд╛ рджрд┐рди рдмреЗрд╣рддрд░реАрди рд╣реЛ! ЁЯШК"
                ]
            },
            'language_changed': {
                'en': "Great! I've switched to English. How can I help you?",
                'es': "┬бExcelente! He cambiado al espa├▒ol. ┬┐C├│mo puedo ayudarte?",
                'fr': "Parfait! J'ai bascul├й en fran├зais. Comment puis-je vous aider?",
                'hi': "рдмрдврд╝рд┐рдпрд╛! рдореИрдВрдиреЗ рд╣рд┐рдВрджреА рдореЗрдВ рдмрджрд▓ рд▓рд┐рдпрд╛ рд╣реИред рдореИрдВ рдЖрдкрдХреА рдХреИрд╕реЗ рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдВ?",
                'de': "Gro├Яartig! Ich habe auf Deutsch umgestellt. Wie kann ich helfen?",
                'it': "Perfetto! Ho cambiato in italiano. Come posso aiutarti?",
                'pt': "├Уtimo! Mudei para portugu├кs. Como posso ajudar?",
                'ja': "ч┤ацЩ┤уВЙуБЧуБДя╝БцЧецЬмшкЮуБлхИЗуВКцЫ┐уБИуБ╛уБЧуБЯуАВуБйуБоуВИуБЖуБлуБКцЙЛф╝ЭуБДуБзуБНуБ╛уБЩуБЛя╝Я",
                'zh': "хдкхе╜ф║Жя╝БцИСх╖▓ч╗ПхИЗцНвхИ░ф╕нцЦЗуАВцИСшГ╜хжВф╜Хх╕охКйцВия╝Я",
                'ko': "ьвЛьК╡ыЛИыЛд! эХЬъ╡ньЦ┤ыбЬ ьаДэЩШэЦИьК╡ыЛИыЛд. ьЦ┤ыЦ╗ъ▓М ыПДьЩАыУЬыж┤ъ╣МьЪФ?",
                'ar': "╪▒╪з╪ж╪╣! ┘Д┘В╪п ╪к╪н┘И┘Д╪к ╪е┘Д┘Й ╪з┘Д╪╣╪▒╪и┘К╪й. ┘Г┘К┘Б ┘К┘Е┘Г┘Ж┘Ж┘К ┘Е╪│╪з╪╣╪п╪к┘Г╪Я",
                'ta': "роЪро┐ро▒рокрпНрокрпБ! роиро╛ройрпН родрооро┐ро┤рпБроХрпНроХрпБ рооро╛ро▒ро┐ропрпБро│рпНро│рпЗройрпН. роиро╛ройрпН роОрокрпНрокроЯро┐ роЙродро╡ роорпБроЯро┐ропрпБроорпН?",
                'te': "р░Ер░жр▒Нр░нр▒Бр░др░В! р░ир▒Зр░ир▒Б р░др▒Жр░▓р▒Бр░Чр▒Бр░Хр▒Б р░ор░╛р░░р▒Нр░Ър▒Бр░Хр▒Бр░ир▒Нр░ир░╛р░ир▒Б. р░ир▒Зр░ир▒Б р░Ор░▓р░╛ р░╕р░╣р░╛р░пр░В р░Ър▒Зр░пр░Чр░▓р░ир▒Б?",
                'mr': "рдЙрддреНрддрдо! рдореА рдорд░рд╛рдареАрдд рдмрджрд▓рд▓реЛ рдЖрд╣реЗ. рдореА рддреБрдореНрд╣рд╛рд▓рд╛ рдХрд╢реА рдорджрдд рдХрд░реВ рд╢рдХрддреЛ?",
                'gu': "рк╕рк░рк╕! рк╣рлБркВ ркЧрлБркЬрк░рк╛ркдрлАркорк╛ркВ ркмркжрк▓рк╛ркИ ркЧркпрлЛ ркЫрлБркВ. рк╣рлБркВ ркдркорк╛рк░рлА ркХрлЗрк╡рлА рк░рлАркдрлЗ ркоркжркж ркХрк░рлА рк╢ркХрлБркВ?",
                'bn': "ржжрзБрж░рзНржжрж╛ржирзНржд! ржЖржорж┐ ржмрж╛ржВрж▓рж╛ржпрж╝ ржкрж░рж┐ржмрж░рзНрждрж┐ржд рж╣ржпрж╝рзЗржЫрж┐ред ржЖржорж┐ ржХрж┐ржнрж╛ржмрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рждрзЗ ржкрж╛рж░рж┐?",
                'pa': "римри╣рйБрид ри╡ризрйАриЖ! риорйИриВ рикрй░риЬри╛римрйА ри╡ри┐рй▒риЪ римрижри▓ риЧри┐риЖ ри╣ри╛риВред риорйИриВ риХри┐ри╡рйЗриВ риорижриж риХри░ ри╕риХрижри╛ ри╣ри╛риВ?"
            },
            'unknown': {
                'en': [
                    "Hmm, I'm still learning that one! But I'm always eager to help in other ways! What else can I do for you? ЁЯШК",
                    "I don't have that feature yet, but I'm growing every day! Is there something else I can help you with? ЁЯМ▒",
                    "That's not in my toolkit right now, but I'd love to help you with something else! What would you like to try? тЬи"
                ],
                'es': [
                    "┬бHmm, todav├нa estoy aprendiendo eso! ┬бPero siempre estoy ansioso por ayudar de otras maneras! ЁЯШК",
                    "No tengo esa funci├│n todav├нa, pero estoy creciendo cada d├нa! ЁЯМ▒"
                ],
                'fr': [
                    "Hmm, j'apprends encore cela! Mais je suis toujours impatient d'aider d'autres fa├зons! ЁЯШК",
                    "Je n'ai pas cette fonction encore, mais je grandis chaque jour! ЁЯМ▒"
                ],
                'hi': [
                    "рд╣рдореНрдо, рдореИрдВ рдЕрднреА рднреА рд╡рд╣ рд╕реАрдЦ рд░рд╣рд╛ рд╣реВрдВ! рд▓реЗрдХрд┐рди рдореИрдВ рд╣рдореЗрд╢рд╛ рдЕрдиреНрдп рддрд░реАрдХреЛрдВ рд╕реЗ рдорджрдж рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдЙрддреНрд╕реБрдХ рд╣реВрдВ! ЁЯШК",
                    "рдореЗрд░реЗ рдкрд╛рд╕ рдЕрднреА рд╡рд╣ рд╕реБрд╡рд┐рдзрд╛ рдирд╣реАрдВ рд╣реИ, рд▓реЗрдХрд┐рди рдореИрдВ рд╣рд░ рджрд┐рди рдмрдврд╝ рд░рд╣рд╛ рд╣реВрдВ! ЁЯМ▒"
                ]
            }
        }
        
        self.setup_voice()
    
    def setup_voice(self):
        """Setup voice properties"""
        try:
            if not self.engine:
                print("ЁЯФД Attempting to reinitialize speech engine...")
                self.engine = pyttsx3.init()
            
            voices = self.engine.getProperty('voices')
            # Try to set a pleasant voice (usually female voice is at index 1)
            if len(voices) > 1:
                self.engine.setProperty('voice', voices[1].id)
            else:
                self.engine.setProperty('voice', voices[0].id)
            
            # Set speech rate (slower for better understanding)
            self.engine.setProperty('rate', 180)
            # Set volume
            self.engine.setProperty('volume', 0.9)
            
            self.speech_working = True
            print("ЁЯФК Voice engine initialized successfully!")
            
        except Exception as e:
            print(f"тЪая╕П Voice setup warning: {e}")
            self.speech_working = False
    
    def speak(self, text):
        """Convert text to speech with improved error handling"""
        print(f"ЁЯдЦ Assistant: {text}")
        
        if not self.speech_working or not self.engine:
            print("ЁЯФЗ Speech is disabled - text response only")
            return
        
        try:
            # Stop any previous speech
            self.engine.stop()
            
            # Add a small delay to ensure engine is ready
            import time
            time.sleep(0.1)
            
            # Say the text
            self.engine.say(text)
            self.engine.runAndWait()
            
            print("тЬЕ Speech completed")
            
        except Exception as e:
            print(f"тЭМ Speech error: {e}")
            print("ЁЯФД Trying to recover speech engine...")
            
            # Try to recover the engine
            try:
                self.engine.stop()
                time.sleep(0.2)
                self.engine = pyttsx3.init()
                self.setup_voice()
                
                if self.speech_working:
                    self.engine.say(text)
                    self.engine.runAndWait()
                    print("тЬЕ Speech recovered successfully")
                else:
                    print("тЭМ Speech recovery failed - continuing with text only")
                    
            except Exception as e2:
                print(f"тЭМ Speech engine recovery failed: {e2}")
                print("ЁЯТб Continuing with text-only responses...")
                self.speech_working = False
    
    def get_random_response(self, category, language=None):
        """Get a random response from a category in the specified language"""
        if language is None:
            language = self.current_language
        
        if language in self.responses[category]:
            return random.choice(self.responses[category][language])
        else:
            # Fallback to English if language not available
            return random.choice(self.responses[category]['en'])
    
    def change_language(self, command):
        """Change the assistant's language based on command"""
        for lang_name, lang_code in self.language_codes.items():
            if lang_name in command.lower():
                self.current_language = lang_code
                response = self.responses['language_changed'].get(lang_code, 
                          self.responses['language_changed']['en'])
                self.speak(response)
                return True
        return False
    
    def get_input_mode(self):
        """Ask user to choose input mode"""
        print("\n" + "="*50)
        print("ЁЯОп Choose your input method:")
        print("1я╕ПтГг  Voice input тЖТ Voice output (speak & hear)")
        print("2я╕ПтГг  Text input тЖТ Voice output (type & hear)")
        print("3я╕ПтГг  Voice only output тЖТ No voice input (type & hear, no mic needed)")
        print("4я╕ПтГг  Auto mode (try voice, fallback to text)")
        print("="*50)
        
        while True:
            try:
                choice = input("Enter your choice (1/2/3/4) or just press Enter for auto mode: ").strip()
                if choice == '' or choice == '4':
                    return 'auto'
                elif choice == '1':
                    return 'voice'
                elif choice == '2':
                    return 'text'
                elif choice == '3':
                    return 'text_only'
                else:
                    print("тЭМ Please enter 1, 2, 3, or 4")
            except KeyboardInterrupt:
                print("\nЁЯСЛ Goodbye!")
                return None

    def listen_voice(self):
        """Listen to user voice input and convert speech to text"""
        recognizer = sr.Recognizer()
        try:
            with sr.Microphone() as source:
                print("ЁЯОд Listening... (Speak now)")
                recognizer.pause_threshold = 1
                recognizer.energy_threshold = 300
                
                # Adjust for ambient noise
                recognizer.adjust_for_ambient_noise(source, duration=0.5)
                audio = recognizer.listen(source, timeout=5, phrase_time_limit=10)
                
                # Use language-specific recognition
                lang_for_recognition = f"{self.current_language}-in" if self.current_language == 'en' else self.current_language
                command = recognizer.recognize_google(audio, language=lang_for_recognition)
                print(f"ЁЯЧгя╕П You said: {command}")
                return command.lower()
                
        except sr.WaitTimeoutError:
            print("тП░ No speech detected.")
            return None
        except sr.UnknownValueError:
            print("тЭМ Sorry, I didn't understand that")
            return None
        except sr.RequestError as e:
            print(f"тЭМ Speech service error: {e}")
            return None
        except Exception as e:
            print(f"тЭМ Microphone error: {e}")
            return None

    def get_text_input(self):
        """Get text input from user"""
        try:
            print("ЁЯТм Type your message (or 'voice' to switch to voice mode):")
            command = input("ЁЯСд You: ").strip()
            if command:
                print(f"ЁЯУЭ You typed: {command}")
                return command.lower()
            return None
        except KeyboardInterrupt:
            print("\nЁЯСЛ Goodbye!")
            return "exit"
        except Exception as e:
            print(f"тЭМ Input error: {e}")
            return None

    def listen(self, input_mode='auto'):
        """Get user input based on selected mode"""
        if input_mode == 'voice':
            return self.listen_voice()
        elif input_mode == 'text' or input_mode == 'text_only':
            # Text input but still give voice output
            return self.get_text_input()
        elif input_mode == 'auto':
            # Try voice first, fallback to text
            print("\nЁЯОп Auto mode: Trying voice input first...")
            print("ЁЯТб Tip: If voice doesn't work, I'll ask for text input!")
            
            voice_command = self.listen_voice()
            if voice_command:
                return voice_command
            
            print("ЁЯФД Voice didn't work, switching to text input...")
            print("ЁЯФК Don't worry, I'll still respond with voice!")
            return self.get_text_input()
        
        return None
    
    def process_command(self, command, input_mode='auto'):
        """Process the user command and respond appropriately"""
        if not command:
            return True, input_mode
        
        # Check for input mode switching
        if command == 'voice':
            print("ЁЯОд Switched to voice input mode!")
            self.speak("Switched to voice input mode! Now you can speak to me!")
            return True, 'voice'
        elif command == 'text':
            print("ЁЯТм Switched to text input mode! I'll still respond with voice.")
            self.speak("Switched to text input mode! Type your messages and I'll respond with my voice!")
            return True, 'text'
        elif command == 'text only' or command == 'textonly':
            print("ЁЯТм Switched to text-only mode! Perfect for quiet environments.")
            self.speak("Switched to text-only input mode! Type your messages and I'll speak back to you!")
            return True, 'text_only'
        elif command == 'auto':
            print("ЁЯОп Switched to auto mode!")
            self.speak("Switched to auto mode! I'll try voice first, then text if needed!")
            return True, 'auto'
        
        # Check for language change requests
        if 'speak in' in command or 'change to' in command or 'switch to' in command:
            if self.change_language(command):
                return True, input_mode
        
        # Check for exit commands
        exit_words = ['exit', 'stop', 'bye', 'goodbye', 'quit', 'see you']
        if any(word in command for word in exit_words):
            goodbye_msg = self.get_random_response('goodbye')
            self.speak(goodbye_msg)
            return False, input_mode
        
        # Process other commands
        if 'play music' in command or 'music' in command:
            music_msg = self.get_random_response('music')
            self.speak(music_msg)
            
        elif 'reminder' in command:
            reminder_msg = self.get_random_response('reminder')
            self.speak(reminder_msg)
            
        elif 'geo politic' in command or 'geopolitics' in command:
            geo_msg = self.get_random_response('geopolitics')
            self.speak(geo_msg)
            
        elif 'hello' in command or 'hi' in command or 'hey' in command:
            greeting_msg = self.get_random_response('greetings')
            self.speak(greeting_msg)
            
        elif 'how are you' in command:
            self.speak("I'm doing fantastic! Thank you for asking! I'm here and ready to help you with anything you need. How are you doing today?")
            
        elif 'what can you do' in command or 'help' in command:
            help_msg = (
                "I'm your friendly assistant! Here's what I can do: "
                "ЁЯО╡ Play music, тП░ Set reminders, ЁЯМН Discuss geopolitics, "
                "ЁЯЧгя╕П Change languages by saying 'speak in' followed by language name, "
                "ЁЯТм Switch input modes - say 'voice' for voice input, 'text' for typing with voice response, or 'auto' for flexible mode, "
                "and have friendly conversations with you! "
                "I always respond with voice no matter how you input your message!"
            )
            self.speak(help_msg)
            
        elif 'thank you' in command or 'thanks' in command:
            self.speak("You're absolutely welcome! It's my pleasure to help you! Is there anything else you'd like me to do?")
            
        else:
            unknown_msg = self.get_random_response('unknown')
            self.speak(unknown_msg)
        
        return True, input_mode
    
    def run(self):
        """Main function to run the assistant"""
        print("ЁЯдЦ Welcome to your Friendly Virtual Assistant!")
        print("тЬи I support multiple input methods and ALWAYS respond with voice!")
        print("ЁЯФК No matter how you communicate with me, I'll always speak back to you!")
        
        # Get initial input mode preference
        input_mode = self.get_input_mode()
        if input_mode is None:
            return
        
        # Initial greeting
        greeting = self.get_random_response('greetings')
        self.speak(greeting)
        
        # Show mode explanations
        mode_explanations = {
            'voice': "ЁЯОд VOICE MODE: Speak to me and I'll speak back!",
            'text': "ЁЯТм TEXT MODE: Type your messages, I'll respond with voice!",
            'text_only': "ЁЯУЭ TEXT-ONLY MODE: Type your messages, I'll speak back! (Perfect when mic isn't available)",
            'auto': "ЁЯОп AUTO MODE: I'll try voice first, fallback to text if needed, always speak back!"
        }
        
        print(f"\n{mode_explanations[input_mode]}")
        print("ЁЯФК I ALWAYS respond with voice - you'll hear me speak!")
        print("ЁЯТм Switch modes anytime: 'voice', 'text', 'text only', or 'auto'")
        print("ЁЯМН Change languages: 'speak in [language name]'")
        print("тЭМ Exit: 'goodbye' or 'exit'")
        print("-" * 60)
        
        while True:
            try:
                command = self.listen(input_mode)
                should_continue, input_mode = self.process_command(command, input_mode)
                if not should_continue:
                    break
                    
                # Show current mode after each interaction
                if command:
                    status = "ЁЯФК Voice Working" if self.speech_working else "ЁЯФЗ Text Only"
                    print(f"ЁЯУН Input mode: {input_mode.upper()} | Status: {status}")
                    print("-" * 30)
                    
            except KeyboardInterrupt:
                print("\n\nЁЯСЛ Goodbye! Thanks for using the assistant!")
                self.speak("Goodbye! Thanks for chatting with me!")
                break
            except Exception as e:
                print(f"тЭМ An error occurred: {e}")
                self.speak("Sorry, something went wrong. Let's try again!")
                continue

# Create and run the assistant
if __name__ == "__main__":
    assistant = FriendlyAssistant()
    assistant.run()