🐍 Object-Oriented Programming (OOP) in Python – Complete Interview-Ready Guide

1. 📌 Introduction to OOP

* **Object-Oriented Programming (OOP):**
  A programming paradigm that models real-world entities as *objects*, which combine **data (attributes)** and **behavior (methods)** into a single unit.
* **Why OOP?**

  * Reusability (via classes & inheritance)
  * Modularity (organizing code logically)
  * Scalability & Maintainability
  * Encapsulation & Security
  * Abstraction of complex systems

---

2. 📦 Core Concepts of OOP

 Class

 A blueprint** for creating objects.
* Defines:

  * **Attributes (data members)** → variables
  * **Methods (behavior)** → functions

```python
class Car:
    wheels = 4   # class attribute
    def __init__(self, brand, model):
        self.brand = brand      # instance attribute
        self.model = model
```

---

### 🔹 Object / Instance

* A **real-world entity** created from a class.
* Example:

```python
car1 = Car("Tesla", "Model S")   # Object creation
```

* **`car1`** is an *instance* of `Car`.

---

### 🔹 Attributes (Data Members)

* **Variables that hold data inside a class or object.**

#### Types of Attributes:

1. **Instance Attributes** → specific to an object

   ```python
   self.brand, self.model
   ```
2. **Class Attributes** → shared by all objects

   ```python
   wheels = 4
   ```
3. **Static Attributes** → constants declared inside the class, accessed via class name

   ```python
   PI = 3.14
   ```

---

### 🔹 Methods

* **Functions defined inside a class.**

#### Types of Methods:

1. **Instance Methods**

   * Operate on instance attributes (`self`)

   ```python
   def display(self):
       print(self.brand, self.model)
   ```

2. **Class Methods**

   * Operate on class-level attributes (`cls`)

   ```python
   @classmethod
   def change_wheels(cls, num):
       cls.wheels = num
   ```

3. **Static Methods**

   * Independent of `cls` and `self`

   ```python
   @staticmethod
   def utility_function(x):
       return x * x
   ```

---

## 3. 🏛️ Types of Classes in Python

1. **User-defined classes**

   ```python
   class Student: pass
   ```

2. **Built-in classes**

   * Examples: `int`, `str`, `list`, `dict`

3. **Abstract classes**

   * Created using `abc` module
   * Cannot be instantiated directly

   ```python
   from abc import ABC, abstractmethod
   class Shape(ABC):
       @abstractmethod
       def area(self): pass
   ```

4. **Concrete classes**

   * Fully implemented classes (can be instantiated).

5. **Inner / Nested classes**

   * Class inside another class

   ```python
   class Outer:
       class Inner:
           pass
   ```

6. **Singleton class**

   * Ensures only *one instance* exists.

---

## 4. 🔑 Four Pillars of OOP

### 1. **Encapsulation**

* Wrapping **data + methods** into a single unit.
* Achieved using **private/protected attributes**.
* Example:

```python
class Bank:
    def __init__(self):
        self.__balance = 0   # private attribute
```

---

 2. **Abstraction**

* Hiding implementation details, showing only *essential features*.
* Achieved using **abstract classes/interfaces**.


from abc import ABC, abstractmethod
class Vehicle(ABC):
    @abstractmethod
    def start(self): pass


3. **Inheritance**

* Deriving a new class from an existing class.

#### Types of Inheritance:

1. **Single Inheritance** → `Child(Base)`
2. **Multiple Inheritance** → `Child(Base1, Base2)`
3. **Multilevel Inheritance** → `Child → Parent → Grandparent`
4. **Hierarchical Inheritance** → multiple children from one parent
5. **Hybrid Inheritance** → combination

---

### 4. **Polymorphism**

* **Poly = Many, Morph = Forms**
* One interface, multiple implementations.

#### Forms:

1. **Method Overriding (Runtime Polymorphism)**

   * Child class redefines parent’s method

   ```python
   class A: 
       def show(self): print("A")
   class B(A): 
       def show(self): print("B")  # override
   ```

2. **Method Overloading (Compile-time Polymorphism)**

   * Python doesn’t support directly but can simulate with default args.

   ```python
   def add(a, b=0, c=0): return a+b+c
   ```

3. **Operator Overloading**

   ```python
   class Point:
       def __init__(self, x): self.x = x
       def __add__(self, other):
           return self.x + other.x
   ```

---

## 5. 🎯 Special Features in Python OOP

### 🔹 Constructors & Destructors

* **`__init__`** → called when object created
* **`__del__`** → called when object destroyed

### 🔹 Dunder (Magic) Methods

* `__str__`, `__repr__`, `__len__`, `__eq__`, `__add__`, etc.

### 🔹 Access Modifiers

* **Public** → `self.name`
* **Protected** → `_name` (convention only)
* **Private** → `__name` (name mangling)

### 🔹 Object Class

* In Python, all classes inherit from `object`.

---

## 6. ⚡ Advanced OOP Interview Tricky Points

* **Difference between classmethod & staticmethod**
* **MRO (Method Resolution Order)** → especially in multiple inheritance
* **`isinstance()` vs `issubclass()`**
* **Shallow copy vs Deep copy** for objects
* **Composition vs Inheritance**
* **Dataclasses (`@dataclass`) in Python 3.7+**

---

## 7. 🚀 Example Summary

```python
class Animal:
    def speak(self): print("Animal Sound")

class Dog(Animal):
    def speak(self): print("Bark")  # overriding

dog = Dog()
dog.speak()  # Bark